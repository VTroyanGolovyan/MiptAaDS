# Практическая работа 2. "Сравнение скорости работы динамического массива и односвязного списка"

Необходимо написать динамический массив и односвязный список. 

Далее необходимо написать два стека: на списке и на массиве.


У стеков должны быть следующие функции:

* struct Stack* stack_ctr(size_t size, size_t element_size) 
создает массив заданного размера, который потом будет изменяться в ходе исполнения (только для массива)


* int push(struct Stack* st) 
Добавляет элемент в конец контейнера, возвращает 1 если добавление успешно, 0 - не успешно


* int top(struct Stack* st, void* buffer) 
Возвращает последний элемент


* int pop(struct Stack* st) 
Удаляет последний элемент, не возвращая его, возвращает 1 - если успех, 0 - если ошибка


* struct Stack* stack_dtr(struct Stack* st) 
Уничтожает контейнер, освобождая память, возвращает nullptr


## Далее провести для них следующие тесты (каждый провести хотя бы по три раза и усреднить время тестов):


Моделирование стека вызова функций. Надо запушить  $`10^6`$ интов, потом удалить половину элементов и запушить четверть - останется 750000 интов. Повторять удаление половины и вставку четверти, пока не останется в стеке меньше 100000 элементов (получится 9 итераций).


Моделирование нагруженного стека вызова функций. Надо запушить  $`10^6`$ интов, потом 100 раз удалить 10000 элементов и добавить столько же. Далее как в первом тесте провести 9 итераций удаления-вставки и снова 100 раз удалить 10000 элементов и добавить столько же.


Моделирование случайной последовательности команд. Надо научиться средствами языка генерировать случайные числа из множества {1,2}. Далее сначала довести размер стека до миллиона, а потом выполнить миллион инструкций следующего вида: каждое выпадение единицы добавлять элемент, а на двойку - попать из стека. Засекать время после доведения размера стека до миллиона.

## Вывод
Какой стек, по вашему мнению, лучше?
